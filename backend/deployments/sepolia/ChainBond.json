{
  "address": "0x6962b2990a3FD1CE5ed0750D644fbDA4203d3e01",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "friend",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "ConsentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "publicScore",
          "type": "uint32"
        }
      ],
      "name": "Rated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "publicScore",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "cid",
          "type": "string"
        }
      ],
      "name": "RatedWithCid",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        }
      ],
      "name": "getDecryptConsent",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        }
      ],
      "name": "getPairLastCid",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        }
      ],
      "name": "getPairPublicStats",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "sum",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "count",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        }
      ],
      "name": "getPairStats",
      "outputs": [
        {
          "internalType": "euint32",
          "name": "sum",
          "type": "bytes32"
        },
        {
          "internalType": "euint32",
          "name": "count",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        },
        {
          "internalType": "externalEuint32",
          "name": "encryptedScore",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "rate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        },
        {
          "internalType": "externalEuint32",
          "name": "encryptedScore",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        },
        {
          "internalType": "string",
          "name": "cid",
          "type": "string"
        },
        {
          "internalType": "uint32",
          "name": "publicScore",
          "type": "uint32"
        }
      ],
      "name": "rateWithCid",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "friend",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "setDecryptConsent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe0f5043a48871aea3d036cb13450ff387f0a0933211cbeba7c54906cedf83189",
  "receipt": {
    "to": null,
    "from": "0x69f39c7c038424f113957801162520542e219a83",
    "contractAddress": "0x6962b2990a3FD1CE5ed0750D644fbDA4203d3e01",
    "transactionIndex": 44,
    "gasUsed": "945507",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd56279113aba9312acfa61525cccfe76f392c330ed0e423f5ebbafbca2221bc2",
    "transactionHash": "0xe0f5043a48871aea3d036cb13450ff387f0a0933211cbeba7c54906cedf83189",
    "logs": [],
    "blockNumber": 9416349,
    "cumulativeGasUsed": "4136762",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "df353ccf495008da4f1ff7ba83c463c7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ConsentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"publicScore\",\"type\":\"uint32\"}],\"name\":\"Rated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"publicScore\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"RatedWithCid\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"getDecryptConsent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"getPairLastCid\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"getPairPublicStats\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"sum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"count\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"}],\"name\":\"getPairStats\",\"outputs\":[{\"internalType\":\"euint32\",\"name\":\"sum\",\"type\":\"bytes32\"},{\"internalType\":\"euint32\",\"name\":\"count\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"},{\"internalType\":\"externalEuint32\",\"name\":\"encryptedScore\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"rate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"},{\"internalType\":\"externalEuint32\",\"name\":\"encryptedScore\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"publicScore\",\"type\":\"uint32\"}],\"name\":\"rateWithCid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"friend\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setDecryptConsent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"ChainBond \\u2014 Encrypted relationship scoring with FHEVM\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDecryptConsent(address,address)\":{\"notice\":\"Returns if a friend is allowed to decrypt the owner's pair stats via front-end decryption.\"},\"getPairLastCid(address,address)\":{\"notice\":\"Last optional message/cid recorded for the pair.\"},\"getPairPublicStats(address,address)\":{\"notice\":\"Returns public clear aggregates for a pair (if used by UI).\"},\"getPairStats(address,address)\":{\"notice\":\"Returns encrypted aggregates for a given pair (owner -> friend).\"},\"rate(address,bytes32,bytes)\":{\"notice\":\"Rate a friend with an encrypted score (0..100). Updates encrypted sum/count and grants decrypt rights to both parties.\"},\"rateWithCid(address,bytes32,bytes,string,uint32)\":{\"notice\":\"Rate with an IPFS CID and a clear public score for optional public stats.\"},\"setDecryptConsent(address,bool)\":{\"notice\":\"Owner sets whether `friend` can decrypt their pair stats using Relayer userDecrypt on returned handles.\"}},\"notice\":\"Implements Zama FHEVM patterns: external encrypted inputs, FHE.fromExternal, on-chain homomorphic ops, handle sharing via FHE.allow.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ChainBond.sol\":\"ChainBond\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@fhevm/solidity/config/ZamaConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {SepoliaZamaOracleAddress} from \\\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\\\";\\nimport {FHE} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {CoprocessorConfig} from \\\"@fhevm/solidity/lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaConfig.\\n * @notice  This library returns the FHEVM config for different networks\\n *          with the contract addresses for (1) ACL, (2) CoprocessorAddress, (3) DecryptionOracleAddress, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama. It also returns the address of the decryption oracle.\\n */\\nlibrary ZamaConfig {\\n    function getSepoliaProtocolId() internal pure returns (uint256) {\\n        /// @note Zama Ethereum Sepolia protocol id is '10000 + Zama Ethereum protocol id'\\n        return 10001;\\n    }\\n\\n    function getSepoliaConfig() internal pure returns (CoprocessorConfig memory) {\\n        return\\n            CoprocessorConfig({\\n                ACLAddress: 0x687820221192C5B662b25367F70076A37bc79b6c,\\n                CoprocessorAddress: 0x848B0066793BcC60346Da1F49049357399B8D595,\\n                DecryptionOracleAddress: SepoliaZamaOracleAddress,\\n                KMSVerifierAddress: 0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC\\n            });\\n    }\\n\\n    function getEthereumProtocolId() internal pure returns (uint256) {\\n        /// @note Zama Ethereum protocol id is '1'\\n        return 1;\\n    }\\n\\n    function getEthereumConfig() internal pure returns (CoprocessorConfig memory) {\\n        /// @note The addresses below are placeholders and should be replaced with actual addresses\\n        /// once deployed on the Ethereum mainnet.\\n        return\\n            CoprocessorConfig({\\n                ACLAddress: address(0),\\n                CoprocessorAddress: address(0),\\n                DecryptionOracleAddress: address(0),\\n                KMSVerifierAddress: address(0)\\n            });\\n    }\\n}\\n\\n/**\\n * @title   SepoliaConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getSepoliaConfig());\\n    }\\n\\n    function protocolId() public pure returns (uint256) {\\n        return ZamaConfig.getSepoliaProtocolId();\\n    }\\n}\\n\\n/**\\n * @title   EthereumConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getEthereumConfig());\\n    }\\n\\n    function protocolId() public pure returns (uint256) {\\n        return ZamaConfig.getEthereumProtocolId();\\n    }\\n}\\n\",\"keccak256\":\"0x01449813b21226f90d34e768e4449e5a1bf164831ccb30dc603e3d9cc9276dc6\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\nimport \\\"encrypted-types/EncryptedTypes.sol\\\";\\n\\n/**\\n * @title IKMSVerifier\\n * @notice This interface contains the only function required from KMSVerifier.\\n */\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes memory decryptionProof\\n    ) external returns (bool);\\n}\\n\\n/**\\n * @title IDecryptionOracle\\n * @notice This interface contains the only function required from DecryptionOracle.\\n */\\ninterface IDecryptionOracle {\\n    function requestDecryption(\\n        uint256 requestID,\\n        bytes32[] calldata ctsHandles,\\n        bytes4 callbackSelector\\n    ) external payable;\\n}\\n\\n/**\\n * @title   FHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with the FHEVM protocol.\\n */\\nlibrary FHE {\\n    /// @notice Returned if some handles were already saved for corresponding ID.\\n    error HandlesAlreadySavedForRequestID();\\n\\n    /// @notice Returned if there was not handle found for the requested ID.\\n    error NoHandleFoundForRequestID();\\n\\n    /// @notice Returned if the returned KMS signatures are not valid.\\n    error InvalidKMSSignatures();\\n\\n    /// @notice This event is emitted when requested decryption has been fulfilled.\\n    event DecryptionFulfilled(uint256 indexed requestID);\\n\\n    /**\\n     * @notice                  Sets the coprocessor addresses.\\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\\n        Impl.setCoprocessor(coprocessorConfig);\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\\n     */\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\\n     */\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\\n     */\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\\n     */\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\\n     */\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\\n     */\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\\n     */\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\\n     */\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\\n     */\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\\n     */\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\\n     */\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\\n     */\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\\n     */\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\\n     */\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\\n     */\\n    function eq(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\\n     */\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\\n     */\\n    function ne(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\\n     */\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\\n     */\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\\n     */\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\\n     */\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\\n     */\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\\n     */\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\\n     */\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\\n     */\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\\n     */\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\\n     */\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\\n     */\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\\n     */\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\\n     */\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\\n     */\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\\n     */\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\\n     */\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\\n     */\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\\n     */\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\\n     */\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\\n     */\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\\n     */\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\\n     */\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\\n     */\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\\n     */\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\\n     */\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\\n     */\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\\n     */\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\\n     */\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\\n     */\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\\n     */\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\\n     */\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\\n     */\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\\n     */\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\\n     */\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\\n     */\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\\n     */\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\\n     */\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\\n     */\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\\n     */\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\\n     */\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\\n     */\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\\n     */\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\\n     */\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\\n     */\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\\n     */\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\\n     */\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\\n     */\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\\n     */\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\\n     */\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\\n     */\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\\n     */\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\\n     */\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\\n     */\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\\n     */\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\\n     */\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\\n     */\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\\n     */\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\\n     */\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\\n     */\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\\n     */\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\\n     */\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\\n     */\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\\n     */\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\\n     */\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\\n     */\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\\n     */\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\\n     */\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\\n     */\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\\n     */\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\\n     */\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\\n     */\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\\n     */\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\\n     */\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\\n     */\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\\n     */\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\\n     */\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\\n     */\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\\n     */\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\\n     */\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\\n     */\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\\n     */\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\\n     */\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\\n     */\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\\n     */\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\\n     */\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\\n     */\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\\n     */\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\\n     */\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\\n     */\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\\n     */\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\\n     */\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\\n     */\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\\n     */\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\\n     */\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\\n     */\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\\n     */\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\\n     */\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\\n     */\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\\n     */\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\\n     */\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\\n     */\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\\n     */\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\\n     */\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\\n     */\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\\n     */\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\\n     */\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\\n     */\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\\n     */\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\\n     */\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\\n     */\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\\n     */\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\\n     */\\n    function eq(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\\n     */\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\\n     */\\n    function ne(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\\n     */\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\\n     */\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\\n     */\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\\n     */\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\\n     */\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\\n     */\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\\n     */\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\\n     */\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\\n     */\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\\n     */\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\\n     */\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\\n     */\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\\n     */\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\\n     */\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\\n     */\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\\n     */\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\\n     */\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\\n     */\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\\n     */\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\\n     */\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\\n     */\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\\n     */\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\\n     */\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\\n     */\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\\n     */\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\\n     */\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\\n     */\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\\n     */\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\\n     */\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\\n     */\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\\n     */\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\\n     */\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\\n     */\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\\n     */\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\\n     */\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\\n     */\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\\n     */\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\\n     */\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\\n     */\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint8'.\\n     */\\n    function asEuint8(ebool b) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\\n     */\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\\n     */\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\\n     */\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\\n     */\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\\n     */\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\\n     */\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint16'.\\n     */\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\\n     */\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\\n     */\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\\n     */\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\\n     */\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\\n     */\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\\n     */\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint32'.\\n     */\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\\n     */\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\\n     */\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\\n     */\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\\n     */\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\\n     */\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\\n     */\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint64'.\\n     */\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\\n     */\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\\n     */\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\\n     */\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\\n     */\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\\n     */\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\\n     */\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint128'.\\n     */\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\\n     */\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\\n     */\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\\n     */\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\\n     */\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\\n     */\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\\n     */\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint256'.\\n     */\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\\n     */\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Evaluates not(ebool value) and returns the result.\\n     */\\n    function not(ebool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint8 value) and returns the result.\\n     */\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint8 value) and returns the result.\\n     */\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint16 value) and returns the result.\\n     */\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint16 value) and returns the result.\\n     */\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint32 value) and returns the result.\\n     */\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint32 value) and returns the result.\\n     */\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint64 value) and returns the result.\\n     */\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint64 value) and returns the result.\\n     */\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint128 value) and returns the result.\\n     */\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint128 value) and returns the result.\\n     */\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint256 value) and returns the result.\\n     */\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint256 value) and returns the result.\\n     */\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\\n     */\\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Converts a plaintext boolean to an encrypted boolean.\\n     */\\n    function asEbool(bool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n     */\\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\\n     */\\n    function asEuint8(uint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n     */\\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\\n     */\\n    function asEuint16(uint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n     */\\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\\n     */\\n    function asEuint32(uint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n     */\\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\\n     */\\n    function asEuint64(uint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n     */\\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\\n     */\\n    function asEuint128(uint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\\n     */\\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\\n     */\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n     */\\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\\n     */\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\\n     *      (input proofs).\\n     *      This could be useful for integration with Account Abstraction when bundling several\\n     *      UserOps calling the FHEVMExecutor.\\n     */\\n    function cleanTransientStorage() internal {\\n        Impl.cleanTransientStorageACL();\\n        Impl.cleanTransientStorageInputVerifier();\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(ebool value, address account) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(ebool value) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(ebool value, address account) internal returns (ebool) {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint8 value, address account) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint8 value) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint16 value, address account) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint16 value) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint32 value, address account) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint32 value) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint64 value, address account) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint64 value) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint128 value, address account) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint128 value) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(eaddress value) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint256 value, address account) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint256 value) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Recovers the stored array of handles corresponding to requestID.\\n     */\\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length == 0) {\\n            revert NoHandleFoundForRequestID();\\n        }\\n        return $.requestedHandles[requestID];\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector\\n    ) internal returns (uint256 requestID) {\\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue\\n    ) internal returns (uint256 requestID) {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        requestID = $.counterRequest;\\n        CoprocessorConfig storage $$ = Impl.getCoprocessorConfig();\\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\\n        IDecryptionOracle($$.DecryptionOracleAddress).requestDecryption{value: msgValue}(\\n            requestID,\\n            ctsHandles,\\n            callbackSelector\\n        );\\n        saveRequestedHandles(requestID, ctsHandles);\\n        $.counterRequest++;\\n    }\\n\\n    /**\\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\\n     * @dev     otherwise fake decryption results could be submitted.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function checkSignatures(uint256 requestID, bytes memory cleartexts, bytes memory decryptionProof) internal {\\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\\n        bool isVerified = verifySignatures(handlesList, cleartexts, decryptionProof);\\n        if (!isVerified) {\\n            revert InvalidKMSSignatures();\\n        }\\n        emit DecryptionFulfilled(requestID);\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\\n     */\\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length != 0) {\\n            revert HandlesAlreadySavedForRequestID();\\n        }\\n        $.requestedHandles[requestID] = handlesList;\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     * @dev The callback function has the following signature:\\n     * - requestID (static uint256)\\n     * - cleartexts (dynamic bytes)\\n     * - decryptionProof (dynamic bytes)\\n     *\\n     * This means that the calldata is encoded in the following way:\\n     * - 4 bytes: selector\\n     * - 32 bytes: requestID\\n     * - 32 bytes: offset of the cleartexts\\n     * - 32 bytes: offset of the decryptionProof\\n     * - 32 bytes: length of the cleartexts (total number of bytes)\\n     * - n*32 bytes: the \\\"n\\\" cleartext values, with \\\"n\\\" the number of handles\\n     * - 32 bytes: length of the decryptionProof (total number of bytes)\\n     * - ... the data of the decryptionProof (signatures, extra data)\\n     */\\n    function verifySignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory cleartexts,\\n        bytes memory decryptionProof\\n    ) private returns (bool) {\\n        // Compute the signature offset\\n        // This offset is computed by considering the format encoded by the KMS when creating the\\n        // \\\"decryptedResult\\\" bytes array (see comment below), which is the following:\\n        // - requestID: 32 bytes\\n        // - all \\\"n\\\" decrypted values (which is \\\"cleartexts\\\" itself): n*32 bytes (\\\"cleartexts.length\\\" bytes)\\n        // - offset of the signatures: 32 bytes\\n        // - the rest of signature values (lengths, offsets, values)\\n        // This means the expected offset to concatenate to the \\\"decryptedResult\\\" bytes array has\\n        // the following value: 32 + n*32 + 32\\n        // See https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types for more details.\\n        // The signature offset will most likely be removed in the future,\\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\\n        uint256 signaturesOffset = 32 + cleartexts.length + 32;\\n\\n        // Built the \\\"decryptedResult\\\" bytes array\\n        // Currently, the \\\"decryptedResult\\\" is encoded (by the KMS) in the following format:\\n        // - n*32 bytes: the \\\"n\\\" decrypted values, \\\"cleartexts\\\" itself\\n        // - 32 bytes: offset of the signatures, as explained above\\n        // This is equivalent to concatenating the cleartexts and the signatures offset, which can\\n        // be done using abi.encoded in a gas efficient way.\\n        // The signature offset will most likely be removed in the future,\\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\\n        // Here we can use \\\"encodePacked\\\" instead of \\\"abi.encode\\\" to save gas, as the cleartexts\\n        // and the signaturesOffset are already 32 bytes aligned (ie, no padding needed).\\n        bytes memory decryptedResult = abi.encodePacked(cleartexts, signaturesOffset);\\n\\n        CoprocessorConfig storage $ = Impl.getCoprocessorConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                handlesList,\\n                decryptedResult,\\n                decryptionProof\\n            );\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\\n        ct = ebool.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\\n        ct = euint8.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\\n        ct = euint16.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\\n        ct = euint32.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\\n        ct = euint64.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\\n        ct = euint128.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\\n        ct = eaddress.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\\n        ct = euint256.unwrap(value);\\n    }\\n}\\n\",\"keccak256\":\"0x7a7b1c85bbef1ad02125f11af2f1c009ab6549075ab8d51d31ae9352f0441f35\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FheType.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nenum FheType {\\n    Bool,\\n    Uint4,\\n    Uint8,\\n    Uint16,\\n    Uint32,\\n    Uint64,\\n    Uint128,\\n    Uint160,\\n    Uint256,\\n    Uint512,\\n    Uint1024,\\n    Uint2048,\\n    Uint2,\\n    Uint6,\\n    Uint10,\\n    Uint12,\\n    Uint14,\\n    Int2,\\n    Int4,\\n    Int6,\\n    Int8,\\n    Int10,\\n    Int12,\\n    Int14,\\n    Int16,\\n    Int32,\\n    Int64,\\n    Int128,\\n    Int160,\\n    Int256,\\n    AsciiString,\\n    Int512,\\n    Int1024,\\n    Int2048,\\n    Uint24,\\n    Uint40,\\n    Uint48,\\n    Uint56,\\n    Uint72,\\n    Uint80,\\n    Uint88,\\n    Uint96,\\n    Uint104,\\n    Uint112,\\n    Uint120,\\n    Uint136,\\n    Uint144,\\n    Uint152,\\n    Uint168,\\n    Uint176,\\n    Uint184,\\n    Uint192,\\n    Uint200,\\n    Uint208,\\n    Uint216,\\n    Uint224,\\n    Uint232,\\n    Uint240,\\n    Uint248,\\n    Int24,\\n    Int40,\\n    Int48,\\n    Int56,\\n    Int72,\\n    Int80,\\n    Int88,\\n    Int96,\\n    Int104,\\n    Int112,\\n    Int120,\\n    Int136,\\n    Int144,\\n    Int152,\\n    Int168,\\n    Int176,\\n    Int184,\\n    Int192,\\n    Int200,\\n    Int208,\\n    Int216,\\n    Int224,\\n    Int232,\\n    Int240,\\n    Int248\\n}\\n\",\"keccak256\":\"0x945f006108fab92cb082a6e5a80525953f17b8d8dcf88a283a83fc80c765497a\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\n/**\\n * @title   CoprocessorConfig\\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\\n */\\nstruct CoprocessorConfig {\\n    address ACLAddress;\\n    address CoprocessorAddress;\\n    address DecryptionOracleAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   DecryptionRequests\\n * @notice  This struct contains the internal counter for requestIDs generated by the dapp,\\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\\n */\\nstruct DecryptionRequests {\\n    uint256 counterRequest;\\n    mapping(uint256 => bytes32[]) requestedHandles;\\n}\\n\\n/**\\n * @title   IFHEVMExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface IFHEVMExecutor {\\n    /**\\n     * @notice              Computes fheAdd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheSub operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMul operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheDiv operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRem operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitAnd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitOr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitXor operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheEq operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMin operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMax operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNeg operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNot operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNot(bytes32 ct) external returns (bytes32 result);\\n    /**\\n     * @notice                Verifies the ciphertext.\\n     * @param inputHandle     Input handle.\\n     * @param callerAddress   Address of the caller.\\n     * @param inputProof      Input proof.\\n     * @param inputType       Input type.\\n     * @return result         Result.\\n     */\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        FheType inputType\\n    ) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Performs the casting to a target type.\\n     * @param ct        Value to cast.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param ct        Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHEIfThenElse operation.\\n     * @param control       Control value.\\n     * @param ifTrue        If true.\\n     * @param ifFalse       If false.\\n     * @return result       Result.\\n     */\\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERand operation.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRand(FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERandBounded operation.\\n     * @param upperBound    Upper bound value.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice                      Returns the address of the InputVerifier contract used by the coprocessor.\\n     * @return inputVerifierAddress Address of the InputVerifier.\\n     */\\n    function getInputVerifierAddress() external view returns (address);\\n}\\n\\n/**\\n * @title   IACL.\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param ciphertext    Ciphertext.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 ciphertext, address account) external;\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) external;\\n\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\\n\\n    /**\\n     * @notice              Allows a list of handles to be decrypted.\\n     * @param handlesList   List of handles.\\n     */\\n    function allowForDecryption(bytes32[] memory handlesList) external;\\n\\n    /**\\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\\n     * @param handle            Handle.\\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\\n     */\\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\\n}\\n\\n/**\\n * @title IInputVerifier\\n * @notice This interface contains the only function required from InputVerifier.\\n */\\ninterface IInputVerifier {\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"confidential.storage.config\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant CoprocessorConfigLocation =\\n        0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700;\\n\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"confidential.storage.decryptionRequests\\\")) - 1)) & ~bytes32(uint256(0xff));\\n    bytes32 private constant DecryptionRequestsStorageLocation =\\n        0x878245876662ba28a480c5ea71726db859fb50222b0a3d7cbbc21cfa336faf00;\\n\\n    /**\\n     * @dev Returns the Coprocessor config.\\n     */\\n    function getCoprocessorConfig() internal pure returns (CoprocessorConfig storage $) {\\n        assembly {\\n            $.slot := CoprocessorConfigLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the DecryptionRequests storage struct.\\n     */\\n    function getDecryptionRequests() internal pure returns (DecryptionRequests storage $) {\\n        assembly {\\n            $.slot := DecryptionRequestsStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @notice                  Sets the coprocessor addresses.\\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        $.ACLAddress = coprocessorConfig.ACLAddress;\\n        $.CoprocessorAddress = coprocessorConfig.CoprocessorAddress;\\n        $.DecryptionOracleAddress = coprocessorConfig.DecryptionOracleAddress;\\n        $.KMSVerifierAddress = coprocessorConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(bytes32 ct) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNeg(ct);\\n    }\\n\\n    function not(bytes32 ct) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNot(ct);\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    /**\\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\\n     * @param inputHandle   Input handle.\\n     * @param inputProof    Input proof.\\n     * @param toType        Input type.\\n     * @return result       Result.\\n     */\\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    /**\\n     * @notice            Performs the casting to a target type.\\n     * @param ciphertext  Ciphertext to cast.\\n     * @param toType      Target type.\\n     * @return result     Result value of the target type.\\n     */\\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).cast(ciphertext, toType);\\n    }\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param value     Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).trivialEncrypt(value, toType);\\n    }\\n\\n    function rand(FheType randType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRand(randType);\\n    }\\n\\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRandBounded(upperBound, randType);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 handle, address account) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the handle to be publicly decryptable.\\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\\n     *                      If not, makePubliclyDecryptable() reverts.\\n     * @param handle        Handle.\\n     */\\n    function makePubliclyDecryptable(bytes32 handle) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        bytes32[] memory handleArray = new bytes32[](1);\\n        handleArray[0] = handle;\\n        IACL($.ACLAddress).allowForDecryption(handleArray);\\n    }\\n\\n    /**\\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageACL() internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageInputVerifier() internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        address inputVerifierAddress = IFHEVMExecutor($.CoprocessorAddress).getInputVerifierAddress();\\n        IInputVerifier(inputVerifierAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\\n     * @param handle        Handle.\\n     * @return isAllowed    Whether the handle can be publicly decrypted.\\n     */\\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\\n    }\\n}\\n\",\"keccak256\":\"0xac25fa2fb870877e0079d8a08e064fcc2b87ff7ce956e11c9a920fc70d82859c\",\"license\":\"BSD-3-Clause-Clear\"},\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\naddress constant SepoliaZamaOracleAddress = 0xa02Cda4Ca3a71D7C46997716F4283aa851C28812;\\n\",\"keccak256\":\"0x1e1117254b0e777ecbb902f3b9bb7d0b10920b7896e5eaa62b5163046685b28b\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/ChainBond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\nimport {FHE, euint32, externalEuint32} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\r\\nimport {SepoliaConfig} from \\\"@fhevm/solidity/config/ZamaConfig.sol\\\";\\r\\n\\r\\n/// @title ChainBond \\u2014 Encrypted relationship scoring with FHEVM\\r\\n/// @notice Implements Zama FHEVM patterns: external encrypted inputs, FHE.fromExternal, on-chain homomorphic ops, handle sharing via FHE.allow.\\r\\ncontract ChainBond is SepoliaConfig {\\r\\n    struct EncryptedStats {\\r\\n        euint32 sum;    // encrypted sum of scores\\r\\n        euint32 count;  // encrypted count of scores\\r\\n    }\\r\\n\\r\\n    struct PublicStats {\\r\\n        uint32 sum;\\r\\n        uint32 count;\\r\\n    }\\r\\n\\r\\n    // user => friend => aggregates\\r\\n    mapping(address => mapping(address => EncryptedStats)) private _pairStats;\\r\\n    // user => friend => public aggregates (for optional public leaderboard/graphs)\\r\\n    mapping(address => mapping(address => PublicStats)) private _pairPublic;\\r\\n\\r\\n    // user => friend => last message/ipfs cid (optional)\\r\\n    mapping(address => mapping(address => string)) private _pairLastCid;\\r\\n\\r\\n    // Access control: whether friend can decrypt the pair stats (mutual consent model)\\r\\n    // owner => friend => consent flag\\r\\n    mapping(address => mapping(address => bool)) private _decryptConsent;\\r\\n\\r\\n    event Rated(address indexed from, address indexed to, uint32 publicScore);\\r\\n    event RatedWithCid(address indexed from, address indexed to, uint32 publicScore, string cid);\\r\\n    event ConsentUpdated(address indexed owner, address indexed friend, bool allowed);\\r\\n\\r\\n    /// @notice Internal rating logic shared by rate and rateWithCid.\\r\\n    function _rate(\\r\\n        address friend,\\r\\n        externalEuint32 encryptedScore,\\r\\n        bytes memory inputProof\\r\\n    ) internal {\\r\\n        require(friend != address(0), \\\"Invalid friend\\\");\\r\\n        require(friend != msg.sender, \\\"Self rating not allowed\\\");\\r\\n\\r\\n        euint32 score = FHE.fromExternal(encryptedScore, inputProof);\\r\\n\\r\\n        EncryptedStats storage s = _pairStats[msg.sender][friend];\\r\\n\\r\\n        s.sum = FHE.add(s.sum, score);\\r\\n        s.count = FHE.add(s.count, FHE.asEuint32(1));\\r\\n\\r\\n        // Share decrypt permissions: contract itself and the rater\\r\\n        FHE.allowThis(s.sum);\\r\\n        FHE.allowThis(s.count);\\r\\n        FHE.allow(s.sum, msg.sender);\\r\\n        FHE.allow(s.count, msg.sender);\\r\\n        // Do NOT auto-share with friend by default (privacy-by-default).\\r\\n        // If consent is enabled later, we will call FHE.allow for the friend.\\r\\n\\r\\n        emit Rated(msg.sender, friend, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice Rate a friend with an encrypted score (0..100). Updates encrypted sum/count and grants decrypt rights to both parties.\\r\\n    function rate(\\r\\n        address friend,\\r\\n        externalEuint32 encryptedScore,\\r\\n        bytes calldata inputProof\\r\\n    ) external {\\r\\n        _rate(friend, encryptedScore, inputProof);\\r\\n    }\\r\\n\\r\\n    /// @notice Rate with an IPFS CID and a clear public score for optional public stats.\\r\\n    function rateWithCid(\\r\\n        address friend,\\r\\n        externalEuint32 encryptedScore,\\r\\n        bytes calldata inputProof,\\r\\n        string calldata cid,\\r\\n        uint32 publicScore\\r\\n    ) external {\\r\\n        _rate(friend, encryptedScore, inputProof);\\r\\n        _pairLastCid[msg.sender][friend] = cid;\\r\\n        unchecked {\\r\\n            PublicStats storage p = _pairPublic[msg.sender][friend];\\r\\n            p.sum += publicScore;\\r\\n            p.count += 1;\\r\\n        }\\r\\n        emit RatedWithCid(msg.sender, friend, publicScore, cid);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns encrypted aggregates for a given pair (owner -> friend).\\r\\n    function getPairStats(address owner, address friend)\\r\\n        external\\r\\n        view\\r\\n        returns (euint32 sum, euint32 count)\\r\\n    {\\r\\n        EncryptedStats storage s = _pairStats[owner][friend];\\r\\n        return (s.sum, s.count);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns public clear aggregates for a pair (if used by UI).\\r\\n    function getPairPublicStats(address owner, address friend)\\r\\n        external\\r\\n        view\\r\\n        returns (uint32 sum, uint32 count)\\r\\n    {\\r\\n        PublicStats storage p = _pairPublic[owner][friend];\\r\\n        return (p.sum, p.count);\\r\\n    }\\r\\n\\r\\n    /// @notice Last optional message/cid recorded for the pair.\\r\\n    function getPairLastCid(address owner, address friend) external view returns (string memory) {\\r\\n        return _pairLastCid[owner][friend];\\r\\n    }\\r\\n\\r\\n    /// @notice Owner sets whether `friend` can decrypt their pair stats using Relayer userDecrypt on returned handles.\\r\\n    function setDecryptConsent(address friend, bool allowed) external {\\r\\n        _decryptConsent[msg.sender][friend] = allowed;\\r\\n\\r\\n        // If enabling consent now, grant friend decrypt permission on current handles\\r\\n        if (allowed) {\\r\\n            EncryptedStats storage s = _pairStats[msg.sender][friend];\\r\\n            FHE.allow(s.sum, friend);\\r\\n            FHE.allow(s.count, friend);\\r\\n        }\\r\\n\\r\\n        emit ConsentUpdated(msg.sender, friend, allowed);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns if a friend is allowed to decrypt the owner's pair stats via front-end decryption.\\r\\n    function getDecryptConsent(address owner, address friend) external view returns (bool) {\\r\\n        return _decryptConsent[owner][friend];\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\",\"keccak256\":\"0x7a211c56e603895d8814e2c84f1cd6bd7e2770681b34531b9b1b260615ef2090\",\"license\":\"MIT\"},\"encrypted-types/EncryptedTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ntype ebool is bytes32;\\n\\ntype euint8 is bytes32;\\ntype euint16 is bytes32;\\ntype euint24 is bytes32;\\ntype euint32 is bytes32;\\ntype euint40 is bytes32;\\ntype euint48 is bytes32;\\ntype euint56 is bytes32;\\ntype euint64 is bytes32;\\ntype euint72 is bytes32;\\ntype euint80 is bytes32;\\ntype euint88 is bytes32;\\ntype euint96 is bytes32;\\ntype euint104 is bytes32;\\ntype euint112 is bytes32;\\ntype euint120 is bytes32;\\ntype euint128 is bytes32;\\ntype euint136 is bytes32;\\ntype euint144 is bytes32;\\ntype euint152 is bytes32;\\ntype euint160 is bytes32;\\ntype euint168 is bytes32;\\ntype euint176 is bytes32;\\ntype euint184 is bytes32;\\ntype euint192 is bytes32;\\ntype euint200 is bytes32;\\ntype euint208 is bytes32;\\ntype euint216 is bytes32;\\ntype euint224 is bytes32;\\ntype euint232 is bytes32;\\ntype euint240 is bytes32;\\ntype euint248 is bytes32;\\ntype euint256 is bytes32;\\n\\ntype eint8 is bytes32;\\ntype eint16 is bytes32;\\ntype eint24 is bytes32;\\ntype eint32 is bytes32;\\ntype eint40 is bytes32;\\ntype eint48 is bytes32;\\ntype eint56 is bytes32;\\ntype eint64 is bytes32;\\ntype eint72 is bytes32;\\ntype eint80 is bytes32;\\ntype eint88 is bytes32;\\ntype eint96 is bytes32;\\ntype eint104 is bytes32;\\ntype eint112 is bytes32;\\ntype eint120 is bytes32;\\ntype eint128 is bytes32;\\ntype eint136 is bytes32;\\ntype eint144 is bytes32;\\ntype eint152 is bytes32;\\ntype eint160 is bytes32;\\ntype eint168 is bytes32;\\ntype eint176 is bytes32;\\ntype eint184 is bytes32;\\ntype eint192 is bytes32;\\ntype eint200 is bytes32;\\ntype eint208 is bytes32;\\ntype eint216 is bytes32;\\ntype eint224 is bytes32;\\ntype eint232 is bytes32;\\ntype eint240 is bytes32;\\ntype eint248 is bytes32;\\ntype eint256 is bytes32;\\n\\ntype eaddress is bytes32;\\n\\ntype ebytes1 is bytes32;\\ntype ebytes2 is bytes32;\\ntype ebytes3 is bytes32;\\ntype ebytes4 is bytes32;\\ntype ebytes5 is bytes32;\\ntype ebytes6 is bytes32;\\ntype ebytes7 is bytes32;\\ntype ebytes8 is bytes32;\\ntype ebytes9 is bytes32;\\ntype ebytes10 is bytes32;\\ntype ebytes11 is bytes32;\\ntype ebytes12 is bytes32;\\ntype ebytes13 is bytes32;\\ntype ebytes14 is bytes32;\\ntype ebytes15 is bytes32;\\ntype ebytes16 is bytes32;\\ntype ebytes17 is bytes32;\\ntype ebytes18 is bytes32;\\ntype ebytes19 is bytes32;\\ntype ebytes20 is bytes32;\\ntype ebytes21 is bytes32;\\ntype ebytes22 is bytes32;\\ntype ebytes23 is bytes32;\\ntype ebytes24 is bytes32;\\ntype ebytes25 is bytes32;\\ntype ebytes26 is bytes32;\\ntype ebytes27 is bytes32;\\ntype ebytes28 is bytes32;\\ntype ebytes29 is bytes32;\\ntype ebytes30 is bytes32;\\ntype ebytes31 is bytes32;\\ntype ebytes32 is bytes32;\\n\\ntype externalEbool is bytes32;\\n\\ntype externalEuint8 is bytes32;\\ntype externalEuint16 is bytes32;\\ntype externalEuint24 is bytes32;\\ntype externalEuint32 is bytes32;\\ntype externalEuint40 is bytes32;\\ntype externalEuint48 is bytes32;\\ntype externalEuint56 is bytes32;\\ntype externalEuint64 is bytes32;\\ntype externalEuint72 is bytes32;\\ntype externalEuint80 is bytes32;\\ntype externalEuint88 is bytes32;\\ntype externalEuint96 is bytes32;\\ntype externalEuint104 is bytes32;\\ntype externalEuint112 is bytes32;\\ntype externalEuint120 is bytes32;\\ntype externalEuint128 is bytes32;\\ntype externalEuint136 is bytes32;\\ntype externalEuint144 is bytes32;\\ntype externalEuint152 is bytes32;\\ntype externalEuint160 is bytes32;\\ntype externalEuint168 is bytes32;\\ntype externalEuint176 is bytes32;\\ntype externalEuint184 is bytes32;\\ntype externalEuint192 is bytes32;\\ntype externalEuint200 is bytes32;\\ntype externalEuint208 is bytes32;\\ntype externalEuint216 is bytes32;\\ntype externalEuint224 is bytes32;\\ntype externalEuint232 is bytes32;\\ntype externalEuint240 is bytes32;\\ntype externalEuint248 is bytes32;\\ntype externalEuint256 is bytes32;\\n\\ntype externalEint8 is bytes32;\\ntype externalEint16 is bytes32;\\ntype externalEint24 is bytes32;\\ntype externalEint32 is bytes32;\\ntype externalEint40 is bytes32;\\ntype externalEint48 is bytes32;\\ntype externalEint56 is bytes32;\\ntype externalEint64 is bytes32;\\ntype externalEint72 is bytes32;\\ntype externalEint80 is bytes32;\\ntype externalEint88 is bytes32;\\ntype externalEint96 is bytes32;\\ntype externalEint104 is bytes32;\\ntype externalEint112 is bytes32;\\ntype externalEint120 is bytes32;\\ntype externalEint128 is bytes32;\\ntype externalEint136 is bytes32;\\ntype externalEint144 is bytes32;\\ntype externalEint152 is bytes32;\\ntype externalEint160 is bytes32;\\ntype externalEint168 is bytes32;\\ntype externalEint176 is bytes32;\\ntype externalEint184 is bytes32;\\ntype externalEint192 is bytes32;\\ntype externalEint200 is bytes32;\\ntype externalEint208 is bytes32;\\ntype externalEint216 is bytes32;\\ntype externalEint224 is bytes32;\\ntype externalEint232 is bytes32;\\ntype externalEint240 is bytes32;\\ntype externalEint248 is bytes32;\\ntype externalEint256 is bytes32;\\n\\ntype externalEaddress is bytes32;\\n\\ntype externalEbytes1 is bytes32;\\ntype externalEbytes2 is bytes32;\\ntype externalEbytes3 is bytes32;\\ntype externalEbytes4 is bytes32;\\ntype externalEbytes5 is bytes32;\\ntype externalEbytes6 is bytes32;\\ntype externalEbytes7 is bytes32;\\ntype externalEbytes8 is bytes32;\\ntype externalEbytes9 is bytes32;\\ntype externalEbytes10 is bytes32;\\ntype externalEbytes11 is bytes32;\\ntype externalEbytes12 is bytes32;\\ntype externalEbytes13 is bytes32;\\ntype externalEbytes14 is bytes32;\\ntype externalEbytes15 is bytes32;\\ntype externalEbytes16 is bytes32;\\ntype externalEbytes17 is bytes32;\\ntype externalEbytes18 is bytes32;\\ntype externalEbytes19 is bytes32;\\ntype externalEbytes20 is bytes32;\\ntype externalEbytes21 is bytes32;\\ntype externalEbytes22 is bytes32;\\ntype externalEbytes23 is bytes32;\\ntype externalEbytes24 is bytes32;\\ntype externalEbytes25 is bytes32;\\ntype externalEbytes26 is bytes32;\\ntype externalEbytes27 is bytes32;\\ntype externalEbytes28 is bytes32;\\ntype externalEbytes29 is bytes32;\\ntype externalEbytes30 is bytes32;\\ntype externalEbytes31 is bytes32;\\ntype externalEbytes32 is bytes32;\\n\",\"keccak256\":\"0x5da9799cd5c30067ea946164722197151baee1f2579a76f01874d4fb25df02a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f5ffd5b5061018a6100ae604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273687820221192c5b662b25367f70076a37bc79b6c815273848b0066793bcc60346da1f49049357399b8d595602082015273a02cda4ca3a71d7c46997716f4283aa851c2881291810191909152731364cbbf2cdf5032c47d8226a6f6fbd2afcdacac606082015290565b80517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970080546001600160a01b03199081166001600160a01b039384161790915560208301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497018054831691841691909117905560408301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497028054831691841691909117905560608301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497038054909216921691909117905550565b610e6b806101975f395ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063da1f12ab11610058578063da1f12ab14610129578063e4f2230614610139578063e814125614610159578063efd6d075146101c1575f5ffd5b80630b2ada15146100895780632f8aab8a146100d957806395ae315d14610101578063a647faf314610116575b5f5ffd5b6100c4610097366004610a3c565b6001600160a01b039182165f90815260036020908152604080832093909416825291909152205460ff1690565b60405190151581526020015b60405180910390f35b6100ec6100e7366004610a3c565b6101d4565b604080519283526020830191909152016100d0565b61011461010f366004610a6d565b610206565b005b610114610124366004610ae4565b6102c1565b60405161271181526020016100d0565b61014c610147366004610a3c565b6103d9565b6040516100d09190610bb6565b6101a4610167366004610a3c565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205463ffffffff808216926401000000009092041690565b6040805163ffffffff9384168152929091166020830152016100d0565b6101146101cf366004610bc8565b610490565b6001600160a01b038083165f9081526020818152604080832093851683529290522080546001909101545b9250929050565b335f9081526003602090815260408083206001600160a01b03861684529091529020805460ff1916821580159190911790915561027b57335f908152602081815260408083206001600160a01b03861684529091529020805461026990846104d6565b506102788160010154846104d6565b50505b60405181151581526001600160a01b0383169033907f0749293cdd24194bfc5a2b093e1784cdba8b1f511563750caa49bb0e4581f4209060200160405180910390a35050565b610301878787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e892505050565b335f9081526002602090815260408083206001600160a01b038b168452909152902061032e838583610cb6565b50335f8181526001602081815260408084206001600160a01b038d16808652925292839020805464010000000063ffffffff8083168901811663ffffffff19841681178390048216909601160267ffffffffffffffff199091169093179290921790915590519091907fb269e0aa265608bb389822c92b7ca47e41f2120bf1d12fdf2e51b1440680e4d7906103c890859088908890610d70565b60405180910390a350505050505050565b6001600160a01b038083165f90815260026020908152604080832093851683529290522080546060919061040c90610c32565b80601f016020809104026020016040519081016040528092919081815260200182805461043890610c32565b80156104835780601f1061045a57610100808354040283529160200191610483565b820191905f5260205f20905b81548152906001019060200180831161046657829003601f168201915b5050505050905092915050565b6104d0848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e892505050565b50505050565b5f6104e18383610672565b5090919050565b6001600160a01b0383166105435760405162461bcd60e51b815260206004820152600e60248201527f496e76616c696420667269656e6400000000000000000000000000000000000060448201526064015b60405180910390fd5b336001600160a01b0384160361059b5760405162461bcd60e51b815260206004820152601760248201527f53656c6620726174696e67206e6f7420616c6c6f776564000000000000000000604482015260640161053a565b5f6105a683836106fb565b335f908152602081815260408083206001600160a01b038916845290915290208054919250906105d6908361070f565b81556001808201546105f0916105eb9061073d565b61070f565b6001820155805461060090610755565b5061060e8160010154610755565b50805461061b90336104d6565b5061062a8160010154336104d6565b506040515f81526001600160a01b0386169033907fc1d70a2ca6ed1aa533080b25cc63be4b4fa9f405bbc83b74a214cacd95c7324b9060200160405180910390a35050505050565b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497008054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b1580156106e0575f5ffd5b505af11580156106f2573d5f5f3e3d5ffd5b50505050505050565b5f61070883836004610764565b9392505050565b5f826107215761071e5f61073d565b92505b816107325761072f5f61073d565b91505b61070883835f610884565b5f61074f8263ffffffff166004610964565b92915050565b5f6107608230610672565b5090565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497015460405163196d0b9b60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b039091169063196d0b9b906107dd908890339089908990600401610dcb565b6020604051808303815f875af11580156107f9573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061081d9190610e0a565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b158015610866575f5ffd5b505af1158015610878573d5f5f3e3d5ffd5b50505050509392505050565b5f5f82156108975750600160f81b61089a565b505f5b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700600181015460405163022f65e760e31b815260048101899052602481018890527fff00000000000000000000000000000000000000000000000000000000000000851660448201529192506001600160a01b03169063117b2f38906064016020604051808303815f875af1158015610936573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061095a9190610e0a565b9695505050505050565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970154604051639cd07acb60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b0390911690639cd07acb906109d99087908790600401610e21565b6020604051808303815f875af11580156109f5573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a199190610e0a565b949350505050565b80356001600160a01b0381168114610a37575f5ffd5b919050565b5f5f60408385031215610a4d575f5ffd5b610a5683610a21565b9150610a6460208401610a21565b90509250929050565b5f5f60408385031215610a7e575f5ffd5b610a8783610a21565b915060208301358015158114610a9b575f5ffd5b809150509250929050565b5f5f83601f840112610ab6575f5ffd5b50813567ffffffffffffffff811115610acd575f5ffd5b6020830191508360208285010111156101ff575f5ffd5b5f5f5f5f5f5f5f60a0888a031215610afa575f5ffd5b610b0388610a21565b965060208801359550604088013567ffffffffffffffff811115610b25575f5ffd5b610b318a828b01610aa6565b909650945050606088013567ffffffffffffffff811115610b50575f5ffd5b610b5c8a828b01610aa6565b909450925050608088013563ffffffff81168114610b78575f5ffd5b8091505092959891949750929550565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6107086020830184610b88565b5f5f5f5f60608587031215610bdb575f5ffd5b610be485610a21565b935060208501359250604085013567ffffffffffffffff811115610c06575f5ffd5b610c1287828801610aa6565b95989497509550505050565b634e487b7160e01b5f52604160045260245ffd5b600181811c90821680610c4657607f821691505b602082108103610c6457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610cb157805f5260205f20601f840160051c81016020851015610c8f5750805b601f840160051c820191505b81811015610cae575f8155600101610c9b565b50505b505050565b67ffffffffffffffff831115610cce57610cce610c1e565b610ce283610cdc8354610c32565b83610c6a565b5f601f841160018114610d13575f8515610cfc5750838201355b5f19600387901b1c1916600186901b178355610cae565b5f83815260208120601f198716915b82811015610d425786850135825560209485019460019092019101610d22565b5086821015610d5e575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b63ffffffff8416815260406020820152816040820152818360608301375f818301606090810191909152601f909201601f1916010192915050565b60548110610dc757634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f610df26080830185610b88565b9050610e016060830184610dab565b95945050505050565b5f60208284031215610e1a575f5ffd5b5051919050565b828152604081016107086020830184610dab56fea2646970667358221220df793bd3b9f3d5b52e21f795572aa3e24676f0e555bd61e06b855d4465a27aac64736f6c634300081b0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063da1f12ab11610058578063da1f12ab14610129578063e4f2230614610139578063e814125614610159578063efd6d075146101c1575f5ffd5b80630b2ada15146100895780632f8aab8a146100d957806395ae315d14610101578063a647faf314610116575b5f5ffd5b6100c4610097366004610a3c565b6001600160a01b039182165f90815260036020908152604080832093909416825291909152205460ff1690565b60405190151581526020015b60405180910390f35b6100ec6100e7366004610a3c565b6101d4565b604080519283526020830191909152016100d0565b61011461010f366004610a6d565b610206565b005b610114610124366004610ae4565b6102c1565b60405161271181526020016100d0565b61014c610147366004610a3c565b6103d9565b6040516100d09190610bb6565b6101a4610167366004610a3c565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205463ffffffff808216926401000000009092041690565b6040805163ffffffff9384168152929091166020830152016100d0565b6101146101cf366004610bc8565b610490565b6001600160a01b038083165f9081526020818152604080832093851683529290522080546001909101545b9250929050565b335f9081526003602090815260408083206001600160a01b03861684529091529020805460ff1916821580159190911790915561027b57335f908152602081815260408083206001600160a01b03861684529091529020805461026990846104d6565b506102788160010154846104d6565b50505b60405181151581526001600160a01b0383169033907f0749293cdd24194bfc5a2b093e1784cdba8b1f511563750caa49bb0e4581f4209060200160405180910390a35050565b610301878787878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e892505050565b335f9081526002602090815260408083206001600160a01b038b168452909152902061032e838583610cb6565b50335f8181526001602081815260408084206001600160a01b038d16808652925292839020805464010000000063ffffffff8083168901811663ffffffff19841681178390048216909601160267ffffffffffffffff199091169093179290921790915590519091907fb269e0aa265608bb389822c92b7ca47e41f2120bf1d12fdf2e51b1440680e4d7906103c890859088908890610d70565b60405180910390a350505050505050565b6001600160a01b038083165f90815260026020908152604080832093851683529290522080546060919061040c90610c32565b80601f016020809104026020016040519081016040528092919081815260200182805461043890610c32565b80156104835780601f1061045a57610100808354040283529160200191610483565b820191905f5260205f20905b81548152906001019060200180831161046657829003601f168201915b5050505050905092915050565b6104d0848484848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506104e892505050565b50505050565b5f6104e18383610672565b5090919050565b6001600160a01b0383166105435760405162461bcd60e51b815260206004820152600e60248201527f496e76616c696420667269656e6400000000000000000000000000000000000060448201526064015b60405180910390fd5b336001600160a01b0384160361059b5760405162461bcd60e51b815260206004820152601760248201527f53656c6620726174696e67206e6f7420616c6c6f776564000000000000000000604482015260640161053a565b5f6105a683836106fb565b335f908152602081815260408083206001600160a01b038916845290915290208054919250906105d6908361070f565b81556001808201546105f0916105eb9061073d565b61070f565b6001820155805461060090610755565b5061060e8160010154610755565b50805461061b90336104d6565b5061062a8160010154336104d6565b506040515f81526001600160a01b0386169033907fc1d70a2ca6ed1aa533080b25cc63be4b4fa9f405bbc83b74a214cacd95c7324b9060200160405180910390a35050505050565b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497008054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b1580156106e0575f5ffd5b505af11580156106f2573d5f5f3e3d5ffd5b50505050505050565b5f61070883836004610764565b9392505050565b5f826107215761071e5f61073d565b92505b816107325761072f5f61073d565b91505b61070883835f610884565b5f61074f8263ffffffff166004610964565b92915050565b5f6107608230610672565b5090565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497015460405163196d0b9b60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b039091169063196d0b9b906107dd908890339089908990600401610dcb565b6020604051808303815f875af11580156107f9573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061081d9190610e0a565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b158015610866575f5ffd5b505af1158015610878573d5f5f3e3d5ffd5b50505050509392505050565b5f5f82156108975750600160f81b61089a565b505f5b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700600181015460405163022f65e760e31b815260048101899052602481018890527fff00000000000000000000000000000000000000000000000000000000000000851660448201529192506001600160a01b03169063117b2f38906064016020604051808303815f875af1158015610936573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061095a9190610e0a565b9695505050505050565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970154604051639cd07acb60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b0390911690639cd07acb906109d99087908790600401610e21565b6020604051808303815f875af11580156109f5573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a199190610e0a565b949350505050565b80356001600160a01b0381168114610a37575f5ffd5b919050565b5f5f60408385031215610a4d575f5ffd5b610a5683610a21565b9150610a6460208401610a21565b90509250929050565b5f5f60408385031215610a7e575f5ffd5b610a8783610a21565b915060208301358015158114610a9b575f5ffd5b809150509250929050565b5f5f83601f840112610ab6575f5ffd5b50813567ffffffffffffffff811115610acd575f5ffd5b6020830191508360208285010111156101ff575f5ffd5b5f5f5f5f5f5f5f60a0888a031215610afa575f5ffd5b610b0388610a21565b965060208801359550604088013567ffffffffffffffff811115610b25575f5ffd5b610b318a828b01610aa6565b909650945050606088013567ffffffffffffffff811115610b50575f5ffd5b610b5c8a828b01610aa6565b909450925050608088013563ffffffff81168114610b78575f5ffd5b8091505092959891949750929550565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f6107086020830184610b88565b5f5f5f5f60608587031215610bdb575f5ffd5b610be485610a21565b935060208501359250604085013567ffffffffffffffff811115610c06575f5ffd5b610c1287828801610aa6565b95989497509550505050565b634e487b7160e01b5f52604160045260245ffd5b600181811c90821680610c4657607f821691505b602082108103610c6457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610cb157805f5260205f20601f840160051c81016020851015610c8f5750805b601f840160051c820191505b81811015610cae575f8155600101610c9b565b50505b505050565b67ffffffffffffffff831115610cce57610cce610c1e565b610ce283610cdc8354610c32565b83610c6a565b5f601f841160018114610d13575f8515610cfc5750838201355b5f19600387901b1c1916600186901b178355610cae565b5f83815260208120601f198716915b82811015610d425786850135825560209485019460019092019101610d22565b5086821015610d5e575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b63ffffffff8416815260406020820152816040820152818360608301375f818301606090810191909152601f909201601f1916010192915050565b60548110610dc757634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f610df26080830185610b88565b9050610e016060830184610dab565b95945050505050565b5f60208284031215610e1a575f5ffd5b5051919050565b828152604081016107086020830184610dab56fea2646970667358221220df793bd3b9f3d5b52e21f795572aa3e24676f0e555bd61e06b855d4465a27aac64736f6c634300081b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "ChainBond — Encrypted relationship scoring with FHEVM",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getDecryptConsent(address,address)": {
        "notice": "Returns if a friend is allowed to decrypt the owner's pair stats via front-end decryption."
      },
      "getPairLastCid(address,address)": {
        "notice": "Last optional message/cid recorded for the pair."
      },
      "getPairPublicStats(address,address)": {
        "notice": "Returns public clear aggregates for a pair (if used by UI)."
      },
      "getPairStats(address,address)": {
        "notice": "Returns encrypted aggregates for a given pair (owner -> friend)."
      },
      "rate(address,bytes32,bytes)": {
        "notice": "Rate a friend with an encrypted score (0..100). Updates encrypted sum/count and grants decrypt rights to both parties."
      },
      "rateWithCid(address,bytes32,bytes,string,uint32)": {
        "notice": "Rate with an IPFS CID and a clear public score for optional public stats."
      },
      "setDecryptConsent(address,bool)": {
        "notice": "Owner sets whether `friend` can decrypt their pair stats using Relayer userDecrypt on returned handles."
      }
    },
    "notice": "Implements Zama FHEVM patterns: external encrypted inputs, FHE.fromExternal, on-chain homomorphic ops, handle sharing via FHE.allow.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 39055,
        "contract": "contracts/ChainBond.sol:ChainBond",
        "label": "_pairStats",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(EncryptedStats)39043_storage))"
      },
      {
        "astId": 39062,
        "contract": "contracts/ChainBond.sol:ChainBond",
        "label": "_pairPublic",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(PublicStats)39048_storage))"
      },
      {
        "astId": 39068,
        "contract": "contracts/ChainBond.sol:ChainBond",
        "label": "_pairLastCid",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_string_storage))"
      },
      {
        "astId": 39074,
        "contract": "contracts/ChainBond.sol:ChainBond",
        "label": "_decryptConsent",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_address,t_string_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => string))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_string_storage)"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(EncryptedStats)39043_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct ChainBond.EncryptedStats))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(EncryptedStats)39043_storage)"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(PublicStats)39048_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct ChainBond.PublicStats))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(PublicStats)39048_storage)"
      },
      "t_mapping(t_address,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_address,t_struct(EncryptedStats)39043_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ChainBond.EncryptedStats)",
        "numberOfBytes": "32",
        "value": "t_struct(EncryptedStats)39043_storage"
      },
      "t_mapping(t_address,t_struct(PublicStats)39048_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ChainBond.PublicStats)",
        "numberOfBytes": "32",
        "value": "t_struct(PublicStats)39048_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(EncryptedStats)39043_storage": {
        "encoding": "inplace",
        "label": "struct ChainBond.EncryptedStats",
        "members": [
          {
            "astId": 39039,
            "contract": "contracts/ChainBond.sol:ChainBond",
            "label": "sum",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(euint32)39452"
          },
          {
            "astId": 39042,
            "contract": "contracts/ChainBond.sol:ChainBond",
            "label": "count",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint32)39452"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(PublicStats)39048_storage": {
        "encoding": "inplace",
        "label": "struct ChainBond.PublicStats",
        "members": [
          {
            "astId": 39045,
            "contract": "contracts/ChainBond.sol:ChainBond",
            "label": "sum",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 39047,
            "contract": "contracts/ChainBond.sol:ChainBond",
            "label": "count",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_userDefinedValueType(euint32)39452": {
        "encoding": "inplace",
        "label": "euint32",
        "numberOfBytes": "32"
      }
    }
  }
}